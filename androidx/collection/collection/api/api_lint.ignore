// Baseline format: 1.0
ArrayReturn: androidx.collection.ArraySet#ArraySet(E[]) parameter #0:
    Method parameter should be Collection<E> (or subclass) instead of raw array; was `E[]`
ArrayReturn: androidx.collection.ArraySet#toArray():
    Method should return Collection<Object> (or subclass) instead of raw array; was `java.lang.Object[]`
ArrayReturn: androidx.collection.ArraySet#toArray(T[]):
    Method should return Collection<T> (or subclass) instead of raw array; was `T[]`
ArrayReturn: androidx.collection.ArraySet#toArray(T[]) parameter #0:
    Method parameter should be Collection<T> (or subclass) instead of raw array; was `T[]`


KotlinOperator: androidx.collection.CircularArray#get(int):
    Method can be invoked with an indexing operator from Kotlin: `get` (this is usually desirable; just make sure it makes sense for this type of object)
KotlinOperator: androidx.collection.CircularIntArray#get(int):
    Method can be invoked with an indexing operator from Kotlin: `get` (this is usually desirable; just make sure it makes sense for this type of object)
KotlinOperator: androidx.collection.LongSparseArray#get(long):
    Method can be invoked with an indexing operator from Kotlin: `get` (this is usually desirable; just make sure it makes sense for this type of object)
KotlinOperator: androidx.collection.LongSparseArray#get(long, E):
    Method can be invoked with an indexing operator from Kotlin: `get` (this is usually desirable; just make sure it makes sense for this type of object)
KotlinOperator: androidx.collection.LruCache#get(K):
    Method can be invoked with an indexing operator from Kotlin: `get` (this is usually desirable; just make sure it makes sense for this type of object)
KotlinOperator: androidx.collection.SimpleArrayMap#get(Object):
    Method can be invoked with an indexing operator from Kotlin: `get` (this is usually desirable; just make sure it makes sense for this type of object)
KotlinOperator: androidx.collection.SparseArrayCompat#get(int):
    Method can be invoked with an indexing operator from Kotlin: `get` (this is usually desirable; just make sure it makes sense for this type of object)
KotlinOperator: androidx.collection.SparseArrayCompat#get(int, E):
    Method can be invoked with an indexing operator from Kotlin: `get` (this is usually desirable; just make sure it makes sense for this type of object)


MissingNullability: androidx.collection.ArrayMap#ArrayMap(androidx.collection.SimpleArrayMap) parameter #0:
    Missing nullability on parameter `map` in method `ArrayMap`
MissingNullability: androidx.collection.LongSparseArray#clone():
    Missing nullability on method `clone` return
MissingNullability: androidx.collection.LongSparseArray#remove(long, Object) parameter #1:
    Missing nullability on parameter `value` in method `remove`
MissingNullability: androidx.collection.LruCache#snapshot():
    Missing nullability on method `snapshot` return
MissingNullability: androidx.collection.SimpleArrayMap#SimpleArrayMap(androidx.collection.SimpleArrayMap<K,V>) parameter #0:
    Missing nullability on parameter `map` in method `SimpleArrayMap`
MissingNullability: androidx.collection.SimpleArrayMap#containsValue(Object) parameter #0:
    Missing nullability on parameter `value` in method `containsValue`
MissingNullability: androidx.collection.SimpleArrayMap#get(Object) parameter #0:
    Missing nullability on parameter `key` in method `get`
MissingNullability: androidx.collection.SimpleArrayMap#getOrDefault(Object, V) parameter #0:
    Missing nullability on parameter `key` in method `getOrDefault`
MissingNullability: androidx.collection.SimpleArrayMap#remove(Object) parameter #0:
    Missing nullability on parameter `key` in method `remove`
MissingNullability: androidx.collection.SimpleArrayMap#remove(Object, Object) parameter #0:
    Missing nullability on parameter `key` in method `remove`
MissingNullability: androidx.collection.SimpleArrayMap#remove(Object, Object) parameter #1:
    Missing nullability on parameter `value` in method `remove`
MissingNullability: androidx.collection.SparseArrayCompat#clone():
    Missing nullability on method `clone` return
MissingNullability: androidx.collection.SparseArrayCompat#remove(int, Object) parameter #1:
    Missing nullability on parameter `value` in method `remove`


NoClone: androidx.collection.LongSparseArray#clone():
    Provide an explicit copy constructor instead of implementing `clone()`
NoClone: androidx.collection.SparseArrayCompat#clone():
    Provide an explicit copy constructor instead of implementing `clone()`


VisiblySynchronized: androidx.collection.LruCache#createCount():
    Internal locks must not be exposed: method androidx.collection.LruCache.createCount()
VisiblySynchronized: androidx.collection.LruCache#evictionCount():
    Internal locks must not be exposed: method androidx.collection.LruCache.evictionCount()
VisiblySynchronized: androidx.collection.LruCache#get(K):
    Internal locks must not be exposed (synchronizing on this or class is still externally observable): method androidx.collection.LruCache.get(K)
VisiblySynchronized: androidx.collection.LruCache#hitCount():
    Internal locks must not be exposed: method androidx.collection.LruCache.hitCount()
VisiblySynchronized: androidx.collection.LruCache#maxSize():
    Internal locks must not be exposed: method androidx.collection.LruCache.maxSize()
VisiblySynchronized: androidx.collection.LruCache#missCount():
    Internal locks must not be exposed: method androidx.collection.LruCache.missCount()
VisiblySynchronized: androidx.collection.LruCache#put(K, V):
    Internal locks must not be exposed (synchronizing on this or class is still externally observable): method androidx.collection.LruCache.put(K,V)
VisiblySynchronized: androidx.collection.LruCache#putCount():
    Internal locks must not be exposed: method androidx.collection.LruCache.putCount()
VisiblySynchronized: androidx.collection.LruCache#remove(K):
    Internal locks must not be exposed (synchronizing on this or class is still externally observable): method androidx.collection.LruCache.remove(K)
VisiblySynchronized: androidx.collection.LruCache#resize(int):
    Internal locks must not be exposed (synchronizing on this or class is still externally observable): method androidx.collection.LruCache.resize(int)
VisiblySynchronized: androidx.collection.LruCache#size():
    Internal locks must not be exposed: method androidx.collection.LruCache.size()
VisiblySynchronized: androidx.collection.LruCache#snapshot():
    Internal locks must not be exposed: method androidx.collection.LruCache.snapshot()
VisiblySynchronized: androidx.collection.LruCache#toString():
    Internal locks must not be exposed: method androidx.collection.LruCache.toString()
VisiblySynchronized: androidx.collection.LruCache#trimToSize(int):
    Internal locks must not be exposed (synchronizing on this or class is still externally observable): method androidx.collection.LruCache.trimToSize(int)

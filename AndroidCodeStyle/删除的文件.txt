#### 3.3.3 顺序和间隔

import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：

* 所有的静态导入独立成组
* Android imports(Android frameworks和supports等依赖库)
* `com.google` imports (仅当这个源文件是在 `com.google` 包下)
* 第三方的包。每个顶级包为一组，字典序。
* 例如: `android`, `com`, `junit`, `org`, `sun`
* `java` imports
* `javax` imports

组内没有空行, 和 imported 的名字出现在ASCII序列 (**注**: 这不是相同的import语句在ASCII排序；相同的分号的存在的结果。


#### 3.4.2 类成员顺序

类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。

最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释 **这排序逻辑**, 比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。

##### 3.4.2.1 重载: 永不分离

当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。


### 4.5 自动换行

**术语说明：**一般情况下，一行长代码为了避免超出列限制(120个字符)而被分为多行，我们称之为 *自动换行*。

我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。

> **提示：**提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)。

#### 4.5.1 从哪里断开

自动换行的基本准则是：更倾向于在**更高的语法级别处**断开. 另外:

1. 如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。
    * 这条规则也适用于以下“类运算符”符号：点分隔符 (`.`), 类型界限中的& (`<T extends Foo & Bar>`), catch块中的管道符号 (`catch (FooException | BarException e)`)。
1. 当一个线被打破时，一个赋值操作符通常会出现中断 后的符号，但无论是哪种方式是可以接受的。
    * 这条规则也适用于 `for` ("foreach") 语句中的分号。
1. 方法或构造函数的名字是附在左括号（ (`(`)）
1. 逗号(`,`) 停留在它前面的标记上。

#### 4.5.2 自动换行时缩进至少+4个空格

自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进)。

当一条语句过长要换行时，我们使用8个空格缩进。例如，正确的缩进为：

```java
Instrument i =
        someLongExpression(that, wouldNotFit, on, one, line);
```

错误的缩进为：

```java
Instrument i =
    someLongExpression(that, wouldNotFit, on, one, line);
```

当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。

在4.6.3 节 水平对齐 中指出， 不鼓励使用可变数目的空格来对齐前面行的符号。


#### 4.6.3 水平对齐：不做要求

**术语说明:** *水平对齐* 指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。

这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。

以下示例先展示未对齐的代码，然后是对齐的代码：

```java
private int x; // this is fine
private Color color; // this too

private int   x;      // permitted, but future edits
private Color color;  // may leave it unaligned
```

> **提示：**对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。

### 4.7 用小括号来限定组：推荐

除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。


##### 4.8.3.1 数组初始化：可写成块状结构

数组初始化可以写成块状结构，比如，下面的写法都是OK的：

```java
new int[] {           new int[] {
  0, 1, 2, 3            0,
}                       1,
                        2,
new int[] {             3,
  0, 1,               }
  2, 3
}                     new int[]
                          {0, 1, 2, 3}
```

4.8.5 注解
***例外:*** 单个的注解可以和签名的第一行出现在同一行。例如：

```java
@Override public int hashCode() { ... }
```

应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：

```java
@Partial @Mock DataLoader loader;
```

参数和局部变量注解没有特定规则。


#### 4.8.7 Modifiers

类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现：

```java
public protected private abstract static final transient volatile synchronized native strictfp
```

#### 4.8.9 if-else特殊情况不能忽视

复杂的逻辑，特别是消息,未处理的都需要打印日志，防止特殊情况下无法查询疑难杂症


#### 5.2.8 类型变量名

类型变量可用以下两种风格之一进行命名：

单个的大写字母，后面可以跟一个数字(如： `E`, `T`, `X`, `T2`)
以类命名方式(见 5.2.2节, 类名), 后面加个大写的T T (例如: `RequestT`, `FooBarT`).

---

## 6 编程实践

### 6.1 @Override:能用则用

一个被标志为 `@Override` ，只要它是合法的。这包括一个类方法覆盖父类的方法，实现接口方法的类的方法，和一个接口方法重新指定父接口。

例外: `@Override` 在父类方法 `@Deprecated` 时候可以被忽略.

6.5 @Nullable: 允许则必须声明

所有 `public` 和 `protected` 成员方法的参数和返回值，如果允许为空的，则必须添加`@Nullable`注解；没有`@Nullable`声明的 `public` 和 `protected` 成员方法的参数和返回值则是`@NonNull`的。(如下面的例子))

```java
@Nullable
@Override
public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { ... }
```
